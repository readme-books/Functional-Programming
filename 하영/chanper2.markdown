# chapter 1

## 액션, 계산, 데이터

- 액션 ) 호출횟수와 시점에 의존
- 계산 ) 어떤것을 계획하거나 결정하는것
- 데이터 ) 변경 불가능한 데이터

## 계층형 설계

- 자주 바뀌는것과 자주 바뀌지 않는것을 기준으로 각 계층을 기반으로 만들어진 코드는 더 안정적인 기반위에 작성될 수 있다.
- 가장위에 있는 코드(자주 바뀌는것) 의존성이 거의 없기때문에 쉽게 바뀔수 있고 아래에 있는 코드들은 의존성이 많아 바꾸기 어렵지만 자주 바뀌지 않는다.
- 가장 아래쪽에는 배열이나 객체 같은 언어기능 / 가운데는 바뀔수도있지만 자주 바뀌지않는것 / 가장 위쪽에는 자주 바뀌는것을 위주로 계층을 설계

## 일급 추상

예시) 피자집을 운영하고있는 토니의 로봇시스템 설계하기

[기존 방식]

- 한 로봇이 치즈 피자를 만든다.
  -> 주문접수 -> 반죽 만들기->펴기->소스만들기-> 소스뿌리기-> 치즈갈기->치즈뿌리기->오븐에 넣기-> 기다렸다 서빙

[분산시스템 적용]

- 3대의 로봇이 치즈피자를 만든다.
  ->주문접수-> 로봇1 반죽만들기
  -> 로봇2 치즈갈기
  -> 로봇3 소스만들기 -> 반죽펴기->소스뿌리기->치즈 뿌리기->오븐에 넣기-> 기다렸다 서빙

: 로봇 세대가 각자의 타임라인을 가지고 동시에 일을 시작하지만 각각의 타임라인에서 처리되는 일은 순서가 섞여 누가 먼저 끝날지 알수 없음. 반죽만들기가 소스만들기보다 늦게 끝난다면 로봇 3은 반죽펴기의 기능을 할 수 없음.

[변경된 분산시스템의 문제점]

- 기본적으로 타임라인은 서로 순서를 맞추지 않는다.
- 액션이 실행되는 시간은 중요하지않다. (각각의 타임라인은 다른 타임라인의 순서와 관계없이 만들어져야한다.)
- 드물지만 타이밍이 어긋나는 경우는 실제로 존재한다. (타임라인은 항상 옳바른 결과를 보장해야한다.)
- 타임라인 다이어그램으로 시스템의 문제를 알수 없다.

[해결하기 위해 도입된 방법 : 타임라인 커팅]
**타임라인 커팅** : 여러 타임라인이 동시에 진행될때 서로 순서를 맞추는 방법 (=== 고차동작)

- 로봇 1,2,3의 각각의 동작 (반죽만들기 / 치즈갈기 / 소스만들기) 행동을 모두가 끝날때까지 더이상 작업을 진행하지 않도록 컷하기
  => 로봇은 다른 작업이 끝나기를 기다리고 모든 작업이 완료되면 로봇 한대가ㅣ 나머지 피자를 완성한다.

# chapter 6 : 변경 가능한 데이터 구조를 가진 언어에서 불변성 유지하기

## 동작을 읽기, 쓰기 또는 둘다로 분류하기

- 읽기) 데이터에서 정보를 가져오는것, 데이터를 바꾸지 않는다. + 값을 리턴한다는 뜻
- 쓰기) 데이터를 바꾸는것

- 쓰기 동작은 불변성 원칙에 따라 _카피-온-라이트_ 로 구현해야한다.

## 카피-온-라이트 원칙 3단계

1. 복사본만들기
2. 복사본 변경하기
3. 복사본 리턴하기
   : 카피-온-라이트는 쓰기를 읽기로 바꾼다.
   => 쓰기동작 -> 카피온라이트 원칙에따라 바꾸고 -> 이렇게 되면 쓰기 동작은 읽기로 바뀌어서 데이터가 바뀌지 않음

## 자바스크립트 배열에서 쓰기와 읽기 동작이 다 있는 것들

- 어떤 메소드들은 읽고 변경하는 일을 동시에한다.
- 즉, pop 이나 push, shift 같은 메소드들은 어떤 특정 엘리먼트를 수정해서 그 값을 리턴한다.
  => 이것이 쓰기와 읽기 동작이 다 있는것들

해결방법 1.함수를 쓰기 와 읽기로 분리하기
해결방법 2. 값을 두개 리턴하기

### 1. 함수를 쓰기와 읽기로 분리하기

- shift()의 메소드의 경우 첫번째 배열을 리턴하지우고 나머지 배열을 리턴함
- 여기서의 읽기 동작은 단순히 첫번째 항목을 리턴하는 계산 함수 -> 배열을 바꾸지 않기때문에 카피온라이트를 적용할 필요 없음

```tsx
function first_element(array){
    retun array[0]
}
```

- 여기서의 쓰기 동작을 카피온라이트로 적용

```tsx
function drop_first(array) {
  var copy = array.slice();
  copy.shift();
  return copy;
}
```

### 2. 값을 두개 리턴하는 함수로 만들기

```tsx
function shift(array) {
  var copy = array.slice();
  var first = array.shift();
  return {
    first: first,
    array: copy,
  };
}
```

## 중간 정리

- 변경 가능한 데이터를 읽는 것은 액션
- 쓰기는 데이터를 변경 가능한 구조로 만드는것
- 어떤 데이터에 쓰기 동작이 없다면 데이터는 변경 불가능한 데이터
- 불변데이터 구조를 읽는것은 계산
- 쓰기를 읽기로 바꾸면 코드에 계산이 많아진다.
- 계산에서는 변경 가능한 데이터에 쓰기를 할 수 없다.

Q) 액션은 변경 가능한 데이터를 읽는것인데 쓰기동작이라고도 할 수 있나?

## 불변데이터 구조에 대해

- 변경 가능한 데이터 구조보다 메모리를 더 많이 쓰고 느리다.
- 언제든 최저화 할 수 있다.
- 가비지 콜렉터기능이 있기때문에 괜찮다.
- 생각보다 많이 복사하지 않는다. -> 얕은 복사 (같은 메모리를 가리키는 참조에 대한 복사본이기 때문에 데이터 구조의 최상위 단계만 복사함)

  _얕은 복사_ : 중첩된 데이터 구조에 최상위 데이터만 복사함. 객체가 들어있는 배열이 있다면 얕은 복사는 배열만 복사하고 안에 있는 객체는 참조로 공유함.
  _구조적 공유_ : 두개의 중첩된 데이터구조가 어떤 참조를 공유하는것. 데이터가 바뀌지 않는 불변 데이터 구조라면 구조적 공유는 안전. 메모리를 적게 사용하고 모든것을 복사하는것 보다 빠르다.

## 객체에 대한 카피온라이트

- 배열의 slice() 메소드 처럼 객체에도 object.assign(a,b) 메소드가 있다.

```jsx
function objectset(ob, key, value) {
  var copy = Object.assign({}, ob); // ob를 복사
  copy[key] = value;
  return copy;
}

function setPrice(item, new_price) {
  return objectset(item, "price", new_price); // item 배열을 새로운 배열로 복사하고 거기 키값 price를 new_price로 바꾼다.
}
const item = {
  name: "티셔츠",
  price: 20000,
  color: "blue",
};

const updatedItem = setPrice(item, 25000);

console.log(updatedItem);
// 결과:
// {
//     name: "티셔츠",
//     price: 25000,
//     color: "blue"
// }

console.log(item);
// 원본은 변경되지 않음:
// {
//     name: "티셔츠",
//     price: 20000,
//     color: "blue"
// }
```

- 중첩된 모든 데이터 구조가 바뀌지 않아야 **불변 데이터**
- 최하위부터 최상위까지 중첩된 데이터 구조의 모든 부분이 불변형이여야함
- 구조적 공유 ) 두 중첩된 데이터 구조에서 안쪽 데이터가 같은 데이터를 참조함

## 얕은 복사와 구조적 공유

- 만약 배열안에 신발, 티셔츠, 양말의 데이터 객체가 있음
- 여기서 배열을 복사하면 복사된 배열도 원래 객체 위에 세개를 가리킴
- 근데 나는 티셔츠의 가격을 바꾸고 싶음
- 이때 티셔츠 객체를 복사하고 가격을 재설정 -> 복사된 배열에서 티셔츠객체만 재설정된 복사된 티셔츠 객체를 가리키도록 바꿈
  -> 나머지 객체는 변경하지도 복사하지도 X

### \# chapter 6

## \' 변경 가능한 데이터 구조를 가진 언어에서 불변성 유지하기 \'

- 데이터가 바뀌지 않도록 하기 위한 `copy-on-write` 적용
- 배열과 객체를 데이터에 쓸 수 있는 `copy-on-write` 동작
- 깊이 중첩된 데이터에 `copy-on-write` 적용<br><br>


<hr>


### 동작 분류

동작을 `읽기` / `쓰기` / `둘 다`로 분류할 수 있음

- `읽기` : 데이터에서 정보를 가져오는 것, 데이터를 변경하지 않음, 값을 리턴함<br>
  인자에만 의존해 정보를 가져오는 읽기 동작(변경 불가능한 데이터를 읽는 것) -> 계산<br>
  변경 가능한 데이터를 읽는 것 -> 액션<br>
- `쓰기` : 데이터를 변경함, 불변성 원칙에 따라 구현해야 함<br><br>


### copy-on-write 3단계

1. 복사본 만들기
2. 복사본 원하는만큼 변경하기
3. 복사본 리턴하기

#### copy-on-write는 `쓰기` -> `읽기`로 변경❗️

데이터를 바꾸지 않고 리턴하기 때문<br><br>


### 읽기와 쓰기를 둘 다 하는 동작을 copy-on-write 적용하기

1. 읽기와 쓰기 함수로 각각 분리<br>
   책임이 확실히 분리되고, 분리된 함수를 따로 사용할 수 있어 더 좋은 방법
2. 함수에서 값을 두 개 리턴<br>
   (1) 복사한 후 값을 두개 리턴<br>
   (2) 분리한 함수를 적용해서 두 개 리턴 -> 분리한 함수 두 개가 다 계산이기 때문에 조합해도 계산임<br><br>



### 불변 데이터 구조

`쓰기`의 역할 : 데이터를 변경 가능하도록 함<br>
쓰기 X -> 데이터는 불변형<br>
불변형 데이터 읽기 -> **계산**<br>

#### 데이터 구조를 불변형으로 만들수록 (쓰기를 읽기로 변경 시) 액션⬇️, 계산⬆

일반적으로 불변 데이터 구조가 변경 가능 데이터 구조보다 메모리를 더 많이 사용하고 느림<br>
그럼에도 대용량의 고성능 시스템 구현하는 사례가 많음, 일반 애플리케이션에 쓰기 충분히 빠름<br>
성능 개선이 필요할 때 언제든 최적화 가능(미리 최적화는 지양, 속도가 느리다면 최적화)<br>
대부분의 언어의 garbage collector 성능 개선이 되어있어 메모리 관리 잘해줌<br>
데이터의 최상위 단계만 복사하는 `얕은 복사(shallow copy)`는 같은 메모리를 가리키는 참조에 대한 복사본을 만들기 때문에 `구조적 공유(structural sharing)` 함<br>
클로저 같은 함수형 프로그래밍 언어는 불변 데이터 구조를 지원, 데이터 구조를 복사할 때 최대한 많은 구조를 공유, 더 적은 메모리를 사용하여 가비지 컬렉터의 부담을 낮춤, copy-on-write를 기반으로 구현되어 있음<br><br>

`🔍 얕은 복사와 구조적 공유`

- `얕은 복사(shallow copy)` : 중첩된 데이터 구조에 최상위 데이터만 복사하는 것<br>
  객체가 들어있는 배열을 얕은 복사하면 배열만 복사하고 안에 있는 객체는 참조로 공유
- `구조적 공유(structural sharing)` : 두 개의 중첩된 데이터 구조가 어떤 참조를 공유하는 것<br>
  데이터가 바뀌지않는 불변 데이터 구조가 구조적 공유할 시 안전함<br>
  메모리를 적게 사용, 모든 것을 복사하는 것보다 빠름<br><br>



### 애플리케이션에는 시간에 따라 변하는 상태가 있다

**전역변수** -> 필요할 때 새로운 값으로 교체(함수형 프로그래밍에서 일번적으로 사용하는 방법)<br>
교체를 사용하면 되돌리기 쉽게 구현 가능<br>
교체를 사용해 애플리케이션을 더욱 견고하게 만들 수 있음<br><br>



### 중첩된 쓰기를 읽기로 변경
중첩된 쓰기도 중첩되지 않은 쓰기와 같은 패턴 사용<br>
복사본 생성 -> 복사본 변경 -> 복사본 리턴<br>
중첩된 항목에 copy-on-write 사용하는 부분이 다름<br>
중첩된 모든 데이터 구조가 바뀌지 않아야 불변 데이터<br>
최하위부터 최상위까지 중첩된 데이터 구조의 모든 부분이 불변형이어야 함<br>
중첩된 데이터의 일부를 변경하려면 변경하려는 값과 상위의 모든 값을 복사해야 함<br><br>


#### 함수형 프로그래밍을 위해선 보일러 플레이트(여러곳에서 비슷한 코드가 반복) 코드를 줄이기 위해<br> 기본적인 배열과 객체 동작에 대한 copy-on-write 버전을 만들어 두는 것이 좋음<br><br>



<hr>

### 객체의 copy-on-write

동일한 3단계로 구현<br>
자바스크립트 객체에는 .slice() 메서드가 없기 때문에 Object.assign() 메서드를 이용하여 복사를 구현

```js
var object = { a: 1, b: 2 };
var object_copy = Object.assign({}, object);
```
<br>


### 자바스크립트 객체 연산 알아보기
다른 언어의 해시 맵, 연관 배열과 비슷<br>
객체는 키와 값으로 되어있음, 키는 객체 안에서 유일, 키는 문자열, 값은 타입 상관 없음

#### 키로 값 찾기

```js
> var object = {a: 1, b: 2};
> object["a"]
1
> object.a
1
```
#### 키로 값 설정하기

```js
> var object = {a: 1, b: 2};
> object["a"] = 7;
1
> object
{a: 7, b: 2}
> object.c = 10;
> object
{a: 7, b: 2, c: 10}
```

#### 키/값 쌍 지우기 `delete`

```js
> var object = {a: 1, b: 2};
> delete object["a"];
true
> object
{b: 2}
```

#### 객체 복사하기 `Object.assign(a, b)`

```js
> var object = {x: 1, y: 2};
> Object.assign({}, object);
{x: 1, y: 2}
```

#### 키 목록 가져오기 `Object.keys()`

```js
> var object = {a: 1, b: 2};
> Object.keys(object);
{"a", "b"}
```
<br>

<hr>

`🔍 불변형 데이터 구조를 기본으로 지원하는 언어`

하스켈(Haskell), 클로저(Clojure), 엘름(Elm), 퓨어스크립트(Purescript), 얼랭(Erlang), 엘릭서(Elixir)
`하스켈(Haskell)`, `클로저(Clojure)`, `엘름(Elm)`, `퓨어스크립트(Purescript)`, `얼랭(Erlang)`, `엘릭서(Elixir)`

변경 가능한 데이터 구조를 기본으로 하는 언어도 불변형 데이터를 사용할 수 있지만 프로그래머의 선택<br>
자바스크립트는 기본적으로 변경 가능한 데이터 구조를 사용하기 때문에 불변성 원칙을 적용하려면 직접 구현해야 함

<hr>
<br>

` 🔍 용어 정리 `
- `중첩된 데이터(nested data)` : 데이터 구조 안에 데이터 구조가 있는 경우<br>
  배열 안에 객체 -> '객체가 배열 안에 중첩되었다'

<br>
<hr>
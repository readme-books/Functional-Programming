### \# chapter 17

## \' 타임라인 조율하기 \'

- 타임라인을 조율하기 위한 동시성 기본형 만들기
- 시간에 관한 중요한 관점인 순서와 반복을 함수형 개발자들이 어떻게 다루는지<br><br>


<hr>


## 좋은 타임라인의 원칙
1. 타임라인은 적을수록 이해하기 쉬움
    - 타임라인이 하나라면 모든 액션은 앞의 액션 다음에 실행됨
    - 멀티스레드나 비동기 콜백, 클라이언트-서버 간 통신을 사용하려면 새로운 타임라인이 필요
2. 타임라인은 짧을수록 이해하기 쉬움
    - 타임라인의 단계를 줄이면 실행 가능한 순서의 수도 많이 줄일 수 있음
3. 공유하는 자원이 적을수록 이해하기 쉬움
    - 서로 다른 타임라인에 있는 액션이 자원을 공유하지 않는다면 실행 순서가 상관 없어짐
    - 실행 가능한 순서의 개수가 줄어들지 않지만, 신경 써야할 실행 가능한 순서를 줄일 수 있음
4. 자원을 공유한다면 서로 조율해야 함
    - 공유 자원을 안전하게 공유(올바른 순서대로 자원을 쓰고 돌려줌)할 수 있어야 함
    - 타임라인 간 조율은 올바른 결과를 주지 않는 실행 순서를 없애는 것
5. 시간을 일급으로 다룸
    - 액션의 순서와 타이밍을 맞추는 것은 어렵지만 타임라인을 다루는 재사용 가능한 객체를 만들면 타이밍을 맞추기 쉬워짐

### 17 챕터 -> 좋은 타임라인 원칙 4, 5

<br>


## 타임라인 조율을 위한 함수 만들기 : Cut()과 JustOnce()

### Cut() : 타임라인을 나누기 위한 동시성 기본형
- 여러 타임라인이 다른 시간에 종료되어도 서로 기다릴 수 있는 간단하고 재사용 가능한 기본형
- ex) 동시에 도착하는 병렬로 처리된 ajax 응답을 모두 받은 후 마지막에 DOM을 업데이트 하도록 cut이라는 시점을 만들기
- cut -> 순서를 보장해주는 역할
- cut의 앞부분과 뒷부분에 있는 액션이 섞이지 않음
- 실행 가능한 순서를 제어함으로써 애플리케이션의 복잡성을 줄여줌

```tsx
function Cut(num, callback) { // num : 기다릴 타임라인의 수, callback : 모든 것이 끝났을 때 실행할 콜백
    var num_finished = 0; // 카운터를 0으로 초기화
    return function() { // 리턴되는 함수는 타임라인이 끝났을 때 호출
        num_finished += 1; // 함수를 호출할 때마다 카운터가 증가함
        if(num_finished === num)
            callback(); // 마지막 타임라인이 끝났을 때 콜백을 호출
    };
}
```


<br>

### JustOnce() : 딱 한 번만 호출하는 기본형
- 액션을 여러번 호출해도 한 번만 실행되도록 만드는 동시성 기본형

```tsx
function JustOnce(action) { // 액션을 전달
    var alreadyCalled = false;
    return function(a, b, c) {
        if(alreadyCalled) return; // 실행한 적이 있따면 바로 종료
        alreadyCalled = true; // 함수가 실행됐다고 생각하고 실행한 사실을 기록
        return action(a, b, c); // 인자와 함께 액션을 호출
    };
}
```


<br>

## 암묵적 시간 모델 vs 명시적 시간 모델

### 자바스크립트의 시간 모델
> 1. 순차적 구문은 순서대로 실행됨   -> 순서
> 2. 두 타임라인에 있는 단계는 왼쪽 먼저 실행되거나, 오른쪽 먼저 실행될 수 있음   -> 순서
> 3. 비동기 이벤트는 새로운 타임라인에서 실행됨   -> 순서
> 4. 액션은 호출할 때마다 실행됨   -> 반복

- 간단한 프로그램에서 암묵적 시간 모델은 좋지만 실행 방식을 바꾸지 못함
- 암묵적 시간 모델의 실행 방식이 에플리케이션에서 필요한 실행 방식과 딱 맞을 일이 없기 때문에 함수형 개발자는 필요한 실행 방식에 가깝게 새로운 시간 모델을 만듦
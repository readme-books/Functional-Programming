### \# chapter 9

## \' 계층형 설계 stratified design 2️⃣ \'

- 코드를 모듈화하기 위해 추상화 벽 만드는 방법
- 좋은 인터페이스가 어떤 것이고, 어떻게 찾는지
- 설계가 이만하면 되었다고 할 수 있는 시점
- 왜 계층형 설계가 유지보수와 테스트, 재사용에 도움이 되는지<br><br>


<hr>


> # 계층형 설계 패턴
> 1. `직접 구현` : 직접 구현된 함수를 읽을 때, 함수 시그니처가 나타내고 있는 문제를 함수 본문에서 적절한 구체화 수준에서 해결해야 함
> 2. `추상화 벽` : 어떤 계층은 중요한 세부 구현을 감추고 인터페이스를 제공함으로써 고수준의 추상화 단계만 생각하여 두뇌 용량의 한계를 극복함
> 3. `작은 인터페이스` : 시스템이 커질수록 비즈니스 개념을 나타내는 중요한 인터페이스는 작고 강력한 동작으로 구성해야 좋음
> 4. `편리한 계층` : 개발자의 요구를 만족시키면서 비즈니스를 잘 풀 수 있도록 소프트웨어를 더 빠르고 고품질로 제공하는데 도움이 되는 계층에 시간을 투자해야 함, 이런 코드가 속한 추상화 계층은 작업할 때 편리해야 함

<br>


## `추상화 벽 abstraction barrier` 이란❓
- 팀 간 책임을 명확하게 나누는 것
- 데이터 구조를 몰라도 함수를 사용할 수 있음
- open API와 유사하게 생각하면 됨(?)
- '어떤 것을 신경쓰지 않아도 되지?'를 표현한 개념
- 계층 구조에서 어떤 계층에 있는 함수들이 공통된 개념을 신경쓰지 않아도 된다면 그 계층을 추상화 벽이라고 할 수 있음
- 추상화 벽은 필요하지 않은 것은 무시할 수 있도록 간접적인 단계를 만듦
- 추상화 벽 아래에 있는 코드와 위에 있는 코드의 의존성을 없앰
- 추상화 벽 위에 있는 함수는 데이터 구조를 몰라도 됨(데이터 구조가 바뀌어도 상관 없음)

### 추상화 벽을 사용하면 좋은 설계를 만들 수 있는 경우
1. 쉽게 구현을 바꾸기 위해
    - 구현에 대한 확신이 없는 경우 : 구현을 간접적으로 사용할 수 있기 때문에 추후 변경 용이
    - 프로토타이핑과 같이 최선의 구현을 확신할 수 없는 작업에 유용
    - 서버에서 데이터를 받아서 처리해야하지만 아직 작업이 되지않아 먼저 임시 데이터를 줘야 하는 경우(바뀔 가능성 높은 경우)
    - 하지만 만약을 대비해 코드를 만드는 경우는 최대한 줄이도록 할 것
2. 코드를 읽고 쓰기 쉽게 만들기 위해
    - 세부적인 것을 신경 쓰지 않고 쉽게 코드를 만들 수 있음
3. 팀 간에 조율해야할 것을 줄이기 위해
    - 각 팀에 관한 구체적인 내용을 서로 신경 쓰지않고 빠르게 일 할 수 있음
4. 주어진 문제에 집중하기 위해
    - 해결하려는 문제의 구체적인 부분을 무시할 수 있어 코드의 실수를 줄일 수 있다

#### 코드를 쉽게 고치려고 사용하기보단 팀 간 커뮤니케이션 비용을 줄이고 복잡한 코드를 명확하게 하기 위해 사용할 것

<br>


## `작은 인터페이스`란❓
- 새로운 코드를 추가할 위치에 관한 것
- 인터페이스를 최소화함으로써 하위 계층에 불필요한 기능이 쓸데없이 커지는 것을 방지할 수 있음
- 새로운 기능을 만들 때 하위 계층에 기능을 추가하거나 고치는 것보다 상위 계층에 만드는 것
- 추상화 벽 뿐만 아니라 모든 계층에 적용할 수 있는 패턴
- 추상화 벽에 만든 함수 === 인터페이스
- 추상화 벽에 있는 인터페이스로 어떤 값의 집합에 접근하거나 값 조작 가능

### 작은 인터페이스 사용 시 장점
- 작은 인터페이스 패턴을 사용하면 깨끗하고 단순하고 믿을 수 있는 인터페이스에 집중할 수 있음
- 감춰진 코드의 나머지 부분을 대신하는 코드로 사용할 수 있음
- 인터페이스가 많아져 생기는 불필요한 변경이나 확장을 방지함

### 추상화 벽을 작게 만들어야 하는 이유
1. 추상화 벽에 코드가 많을수록 구현이 변경되었을 때 수정사항이 많음
2. 추상화 벽에 있는 코드는 낮은 수준의 코드이기 때문에 더 많은 버그가 있을 수 있음
3. 낮은 수준의 코드는 이해하기 어려움
4. 추상화 벽에 코드가 많을수록 텀 간 조율해야할 것도 많아짐
5. 추상화 벽에 인터페이스가 많으면 알아야할 것이 많아 사용하기 어려움

#### 상위 계층에 함수 생성 시 현재 계층에 있는 함수로 구현하는 것이 작은 인터페이스를 실천하는 방법
#### 이상적인 계층은 필요한 함수만 가지고 있어야 함
#### 계층이 가진 함수는 완전하고, 적고, 시간이 지나도 바뀌지않아야 함 => 작은 인터페이스가 전체 계층에 사용되는 이상적인 모습

<br>


## `편리한 계층 comfortable layer` 이란❓
- 이상적인 계층 구성을 만드는 앞의 세 개의 패턴과 다르게 현실적이고 실용적인 측면을 다루는 패턴
- 언제 패턴을 적용하고 언제 멈춰야 하는지 실용적인 방법을 제시
- 작업하는 코드가 편리하다고 느낀다면 설계를 멈춰도 됨
- 반복문을 감싸지 않고 그대로 두고 호출 화살표가 길어지거나 계층이 다른 계층과 섞여도 그대로 둘 것
- 하지만 구체적인 것을 너무 많이 알아야 하거나, 코드가 지저분하다고 느껴진다면 다시 패턴을 적용하라

<br>


## 호출 그래프의 구조로 알 수 있는 비기능적 요구사항
호출 그래프에 함수 이름을 없애면 코드 위치를 통해 세 가지 중요한 비기능적 요구사항을 알 수 있음
- **기능적 요구사항** : 소프트웨어가 정확히 해야하는 일
- **비기능적 요구사항** : 테스트를 어떻게 할 것인지, 재사용을 잘할 수 있는지, 유지보수하기 어렵지 않은지 => 소프트웨어 설계를 하는 중요한 이유
    - `유지보수성 (maintainability)` : 요구 사항이 바뀌었을 때 가장 쉽게 고칠 수 있는 코드는 어떤 코드인지    
        - 그래프의 가장 위에 있는 코드가 유지보수성이 좋음
        - 시간이 지나도 변하지 않는 코드는 가장 아래 계층에 있어야 함
        - 자주 바뀌는 코드는 그래프 위에 있어야 함, 적게 유지하는 것이 좋음
    - `테스트성 (testability)` : 어떤 것을 테스트하는 것이 가장 중요한지
        - 그래프의 아래에 있는 함수에 대한 테스트 코드는 변경 사항이 적은 만큼 오래 사용할 수 있어 효율적임
        - 반면 위에 있는 함수는 자주 바뀌기 때문에 테스트도 오래가지 않아 비효율적임
    - `재사용성 (reusability)` : 어떤 함수가 재사용하기 좋은지
        - 낮은 계층의 함수는 재사용성이 좋음
        - 계층형 구조를 만들면 재사용성이 좋아짐, 낮은 계층으로 함수를 추출하면 재사용성이 좋아지기 때문

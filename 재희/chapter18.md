### \# chapter 18

## \' 반응형 아키텍처와 어니언 아키텍처 \'

- 반응형 아키텍처로 순차적 액션을 파이프라인으로 만드는 방법
- 상태 변경을 다루기 위한 기본형
- 도메인과 현실 세계의 상호작용을 위한 어니언 아키텍처
- 여러 계층에 어니언 아키텍처를 적용하는 방법
- 전통적인 계층형 아키텍처와 어니언 아키텍처 비교<br><br>


<hr>


## 반응형 아키텍처
- 순차적 액션 단계에 사용
- 코드에 나타난 순차적 액션의 순서를 뒤집음(X를 하고 Y를 하는 대신, X가 일어나면 언제나 Y하도록) -> 코드 가독성, 유지보수성 증가
- 효과와 효과에 대한 원인을 분리해서 코드에서 복잡하게 꼬인 부분을 풀 수 있음
- 애플리케이션을 구조화 하는 방법
- 핵심 원칙 : 이벤트에 대한 반응으로 일어날 일을 지정하는 것
- 웹 서비스(웹 요청에 일어날 일을 지정), UI(버튼 클릭과 같은 이벤트 응답에 일어날 일을 지정)와 같은 이벤트 핸들러와 잘 어울림

### 반응형 아키텍처 적용
- **ValueCell()** : 변경 가능한 값을 일급함수로 만드는 코드 (+ 감시자 기능을 추가해 셀의 상태가 바뀔 때 등록된 모든 감시자를 실행하는 반응형 핸들러 함수로)
```tsx
function ValueCell(initialValue) {
    var currentValue = initialValue; // 변경 불가능한 값(컬렉션이 될 수 있음)을 하나 담아 두기
    return { // 리턴되는 함수는 타임라인이 끝났을 때 호출
        val : function () { // 현재 값을 가져옴
            reuturn currentValue;
        },
        update: function (f) { // 현재 값에 함수를 적용해 값을 바꿈(교체 패턴) -> 반드시 액션이 아닌 계산을 전달
            var oldValue = currentValue;
            var newValue = f(oldValue);
            currentValue = newValue;
        }
    };
}
```

-> 감시자를 추가하여 반응형으로 변경
```tsx
function ValueCell(initialValue) {
    var currentValue = initialValue;
    var watchers = []; // 감시자 목록을 저장
    return {
        val : function () {
            reuturn currentValue;
        },
        update: function (f) {
            var oldValue = currentValue;
            var newValue = f(oldValue);
            if(oldValue !== newValue) {
                currentValue = newValue;
                forEach(watchers, function(watcher) { // 값이 바뀔 때 모든 감시자를 실행
                    watcher(newValue);
                })
            }
        },
        addWatchers: function(f) { // 새로운 감시자를 추가
            watchers.push(f);
        }
    };
}
```


<br><br>

- **FormulaCell()** : 어떤 값이 바뀌면 따라서 바뀌는 파생된 값을 관리하는 기본형
```tsx
function FormulaCell(upstreamCell, f) {
    var myCell = ValueCell(f(upstreamCell.val())); // ValueCell을 재사용
    upstreamCell.addWatcher(function(newUpstreamValue) { // 셀 값을 다시 계산하기 위해서 감시자를 추가
        myCell.update(function(currentValue) {
            return f(newUpstreamValue);
        });
    });
    return { // val()과 addWatcher()를 myCell에 위임
        val: myCell.val,
        addWatcher: myCell.addWatch // FomulaCell 값은 직접 바꿀 수 없음
    };
}
```


<br>

### 함수형 프로그래밍과 변경 가능한 상태
- 함수형 프로그래밍을 비롯한 모든 소프트웨어는 변경 가능한 상태를 잘 관리해야 함
- 소프트웨어는 변화하는 현실 세계로부터 정보를 가져와 일부를 저장해야하기 때문에 사용자와 사용자의 행동을 파악하는 것이 중요
- 상태가 외부 데이터베이스에 있는지, 메모리에 있는지보다 상태를 가능한 한 안전하게 사용하는 것이 중요
- ValueCell의 update() 메서드를 사용하면 현재 값을 항상 올바르게 유지할 수 있음 -> update 사용 시 계산을 넘기기 때문
- 현재 값이 도메인 상에서 올바른 값이고 계산이 항상 올바른 값을 리턴한다면 항상 올바른 값을 유지 가능


<br>

### 반응형 아키텍처가 바꾼 시스템의 결과
1. 원인과 효과가 결합된 것을 분리
    - 원인(m)과 효과(n)가 결합되어있는 경우 한 가지를 고치면 관리해야할 것이 m x n개가 됨
    - 분리하게 되면 효과를 추가해도 원인을 고치지않아도 되고, 원인을 추가해도 효과를 고치지않아도 되기 때문에 관리해야할 것은 하나만 늘어남
    - 다만 원인과 효과의 중심이 없다면 분리하는 것은 좋지 않을 수 있음 -> 코드에 액션을 순서대로 표현하는 것이 명확할 수 있음
2. 여러 단계를 파이프라인으로 처리
    - 13장에서 함수형 도구(간단한 함수)로 여러 계산을 조합하듯(재사용하기 좋음) 반응형 아키텍처도 간단한 액션과 계산을 조합해 복잡한 동작을 만들 수 있음
    - 조합된 액션은 파이프라인과 같음, 데이터가 파이프라인으로 들어가 각 단계에서 처리됨
    - 파이프라인 : 작은 액션과 계산을 조합한 하나의 액션
    - 어떤 일이 발생하는 여러 단계가 있는 경우 파이프라인으로 처리
    - 반응형 프레임워크를 사용해 구현하기도 함, 자바스크립트의 경우 Promise로 액션과 계산을 조합해 구현 가능, Promise는 단일값을 전달할 수 있어 파이프라인 단계 간 데이터 전달 가능
    - 단, 여러 단계가 있지만 데이터를 전달하지 않는다면 파이프라인이라고 볼 수 없으므로 이 패턴을 적용하지 않는 것이 좋음
3. 타임라인이 유연해짐
    - 순서를 정의하는 방법을 뒤집기 때문에 자연스럽게 타임라인이 적은 부분으로 분리됨
    - 짧은 타임라인 & 적은 타임라인이 좋지만, 공유하는 자원이 없다면 타임라인이 많아도 문제 없음
    - ValueCell()과 FormulaCell()은 감시자를 호출할 때 현재 값을 넘겨주기 때문에 해당 값을 전역변수로 사용하지 않아도 되고 직접 읽을 필요가 없음, 타임라인이 서로 다른 자원을 사용하기 때문에 안전함


<br><br><br>



## 어니언 아키텍처
- 서비스의 모든 단계에 사용, 반응형 아키텍처보다 더 넗은 범위에 사용
- 웹 서비스나 온도 조절 장치 같은 현실 세계와 상호작용하기 위한 서비스 구조를 만듦
- 함수형 사고 적용 시 자연스럽게 사용할 수 있는 아키텍처
- 반응형 아키텍처와 함께 사용 시 반응형 아키텍처가 어니언 아키텍처 안에 들어있는 것을 볼 수 있지만 서로 의존하지는 않음
- 둥글게 겹겹이 쌓인 양파 모양
    - 인터렉션 계층 : 바깥 세상에 영향을 주거나 받는 액션
    - 도메인 계층 : 비즈니스 규칙을 정의하는 계산
    - 언어 계층 : 언어 유틸리티와 라이브러리
- 액션과 계산의 분리, 계층형 설계 방식과 잘 맞음
- 4장에서 배운 방식으로 액션에서 계산을 빼내면 의도하지 않아도 어니언 아키텍처가 됨
- 함수형 프로그래밍을 할때 높은 차원에서 서비스를 구조화하기 좋은 방법
- 계층형 설계에서 어떤 박스가 액션이라면 박스 위쪽 경로에 있는 모든 박스는 액션이 됨, 그래프에 어떤 액션이 있다면 그래프의 가장 위에 있는 것은 액션이 됨

### 어니언 아키텍처의 특징 3가지
1. 현실 세계와 상호작용은 인터렉션 계층에서 해야 함
2. 계층에서 호출하는 방향은 중심 방향임
3. 계층은 외부에 어떤 계층이 있는지 모름


<br>

## 계층형 아키텍처
- 전통적인 아키텍처로 웹 API를 만들 때 계층이라고 하는 개념을 사용, 어니언 아키텍처와는 다름
- 웹 서버를 만들 때 사용하는 전형적인 계층
    - 웹 인터페이스 계층 : 웹 요청을 도메인으로 바꾸고 도메인을 웹 응답으로 바꿈
    - 도메인 계층 : 애플리케이션 핵심 로직으로 도메인 개념에 DB 쿼리나 명령이 들어감
    - 데이터베이스 계층 : 시간에 따라 바뀌는 정보를 저장
- 전통적인 계층형 아키텍처는 데이터 베이스를 기반으로 도메인 계층은 데이터베이스 동작으로 만듬, 웹 인터페이스는 웹 요청을 도메인 동작으로 변환함
- 데이터베이스 계층이 가장 아래 있다면 그 위에 있는 모든 것이 액션이 되기 때문에 함수형 스타일이 아님
- 모든 것이 계층에 쌓여있고 계산은 따로 관리되지않고 우연히 사용됨
- 함수형 아키텍처는 계산과 액션에 대한 명확한 규칙이 있어야 함


<br>

## 함수형 아키텍처 (ex.어니언 아키텍처)
- 계층형 아키텍처와의 차이점은 데이터베이스 계층과 도메인 계층의 관계
    - 함수형 아키텍처는 도메인 계층이 데이터베이스 계층의 의존하지 않음
    - 데이터베이스 동작은 값을 바꾸거나 데이터베이스에 접근하기 때문에 액션임
- 데이터베이스는 변경 가능하고 접근하는 모든 것을 액션으로 만든다는 것이 핵심
- 도메인 동작을 포함해 그래프에 가장 위에 있는 것까지 모두 액션이 됨
- 함수형 개발자는 액션에서 계산을 빼내려하기 때문에 액션과 계산을 명확하게 구분하고 도멩니 로직은 모두 계산으로 만들어야 함 -> 데이터베이스를 도메인과 분리하는 것이 중요
- 가장 위에 있는 액션에서 도메인 규칙과 데이터베이스를 조합


<br>

### 어니언 아키텍처의 특징 : 변경과 재사용이 쉬움
- 소프트웨어 아키텍처는 변화를 다루는 일, 어니언 아키텍처는 가장 위에 있는 인터랙션 계층(데이터베이스, API 호출과 같은 외부 서비스)을 바꾸기 쉬움
- 도메인이 데이터베이스나 웹 요청에 의존하지 않아 인터렉션 계층에 속하는 데이터베이스와 서비스 프로토콜을 쉽게 바꿀 수 있음 -> 테스트하기 좋음
- 어니언 아키텍처는 좋은 인프라보다 좋은 도메인을 강조함
- 도메인 계층이 데이터베이스나 서비스를 사용하지 않아 전부 계산으로 만들 수 있음 -> 재사용하기 좋음

<br>

### 전통적인 (계층형) 아키텍처 vs 어니언 (함수형) 아키텍처 동작 예시 

|  | 전통적인 (계층형) 아키텍처 | 어니언 (함수형) 아키텍처 |
| :--: | :--: | :--: |
| 장바구니 합계 합산 | 도메인 규칙이 데이터베이스에서 <br> 합계를 가져와 처리 | 핸들러가 데이터베이스에서 <br> 장바구니를 가져와 도메인에 전달<br> 도메인이 합산 |
| `도메인` | 액션 | 계산 |

<br>

### 도메인 -> 액션? 계산? 고민될 때
1. 도메인 규칙은 도메인 용어를 사용함
    - 도메인 규칙(= 비즈니스 규칙) : 프로그램의 핵심 로직
    - 도메인 용어 ex. 제품(product), 이미지(image), 가격(price), 할인(discount)
    - 이런 용어가 쓰이지 않은 코드는 인터랙션 계층에 속하는 코드임
2. 가독성이 어울리는지 따져보기
    - 가독성을 결정하는 요소
        - 사용하는 언어
        - 레거시 코드와 코드 스타일
        - 사용하는 라이브러리
        - 개발자들의 습관
    - 일반적으로 함수형 코드는 읽기 좋지만 아닌 코드가 더 명확한 경우도 있음
        - 도메인 게층을 계산으로 만들어 인터랙션 계층과 분리하면서 읽기 좋은 코드로 만들기 위해 노력해야함
    - 개발 기간의 압박이 있을 경우 나중에 아키텍처에 맞춰 코드를 정리할 준비를 하는 것이 좋음
        - 계산을 추출하고 함수형 도구로 코드를 연결하고 타임라인을 잘 관리할 것
    - 변경 가능한 데이터 구조(액션)는 불변 데이터 구조(계산)보다 빠르기 때문에 성능과 타협해야하는 경우도 있음
        - 성능 개선과 도메인을 계산으로 만드는 것은 따로 생각하는 것이 좋음
        - 최적화는 인터랙션 계층에서 하고 도메인 계층은 재사용 가능한 계산으로 만들기

<br>
<hr>

` 🔍 정리 `
- `감시자(watcher)`와 같은 개념의 다른 이름들 : `이벤트 핸들러(event handler)`, `옵저버(observer)`, `콜백(callback)`, `리스너(listener)`
- 함수형 언어와 프레임워크들에 ValueCell과 유사한 개념들
    - 클로저 -> Atom
    - 엘릭서 -> Agent
    - 리액트 -> Redux의 store, Recoil의 atom
    - 하스켈 -> TVar

<hr>
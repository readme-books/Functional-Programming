### \# chapter 13

## \' 함수형 도구 체이닝 \'

- 복합적인 쿼리로 데이터를 조회하기 위해 함수형 도구를 조합하는 방법
- 복잡한 반복문을 함수형 도구 체인으로 바꾸는 방법
- 데이터 변환 파이프라인을 만들어 작업을 수행하는 방법<br><br>


<hr>


## 함수형 도구 체이닝 : 체인을 명확하게 만드는 방법 2가지
- 체인 : 원하는 결과에 가까워지도록 데이터를 한 단계씩 변환하는 동작
- 함수형 도구를 체인으로 조합하면 복잡한 계산을 작고 명확한 단계로 표현 가능

### 방법 1 _ 단계에 이름 붙이기
- 각 단계에 이름을 붙이면 동작이 명확해짐
- 각 단계에 숨어 있던 함수의 구현도 알아보기 쉬워짐

### 방법 2 _ 콜백에 이름 붙이기
- 인라인으로 사용하던 콜백함수를 빼내 이름을 붙여 재사용할 수 있도록 함
- 콜백 함수를 뽑아 만든 함수는 호출 그래프의 아래쪽에 위치 -> 재사용성 좋음

<br>

### 단계에 이름 붙이기 vs 콜백에 이름 붙이기
- 일반적으로 콜백에 이름 붙이는 방법이 더 명확함
- 고차 함수를 그대로 사용하는 첫번째 방법보다 두번째 방법이 재사용하기 더 좋음
- 인라인 대신 이름 붙인 콜백을 사용하면 단계가 중첩되는 것을 막을 수 있음
- 단, 사용하는 언어의 문법과 문맥에 따라 다를 수 있으니 두가지 방법을 다 고려해보고 좋은 코드로 결정할 것

<br>

## 체인 최적화 : `스트림 결합 stream fusion`
- map(), filter() 함수는 호출될 때마다 새로운 배열이 생기기 때문에 비효율적이라고 생각할 수 있지만 가비지 컬렉터가 있어 대부분 문제되지 않음
- 하지만 비효율적인 경우 체인 최적화하면 됨
- 병목이 생겼을 때만 사용하는 것이 좋고 대부분 여러 단계를 사용하는 것이 더 명확하고 가독성 좋음

### 값 하나에 map()을 두 번 부르는 경우

### 변경 전
```js
var name = map(customers, getFullName);
var nameLengths = map(names, stringLength);
```

### 변경 후
```js
var name = map(customers, function(customer) {
  return stringLength(getFullName(customer));
});
```
<br>

### 값 하나에 filter()를 두 번 부르는 경우

### 변경 전
```js
var goodCustomers = filter(customers, isGoodCustomer);
var withAddresses = filter(goodCustomers, hasAddress);
```

### 변경 후
```js
var withAddresses = filter(customers, function(customer) {
  return isGoodCustomer(customer) && hasAddress(customer);
});
```
<br>

### map() 다음에 reduce()를 사용하는 경우

### 변경 전
```js
var purchaseTotals = map(purchases, getPurchaseTotal);
var purchaseSum = reduce(purchaseTotals, 0, plus);
```

### 변경 후
```js
var purchaseSum = reduce(purchases, 0, function(purchase) {
  return total + getPurchaseTotal(purchase); // reduce() 콜백에서 계산
});
```

<br>
<br>

## 반복문을 함수형 도구로 리팩터링
- 기존에 있던 반복문 코드를 함수형 도구 체이닝 해아하는 경우

### 전략1 : 이해하고 다시 만들기
어떤 일을 하는지 파악한 다음 구현을 아예 새로 하는 방법

### 전략2 : 단서를 찾아 리팩터링
반복문을 하나씩 함수형 도구 체인으로 변경<br>

#### 리팩터링 팁

- 데이터 만들기<br>
함수형 도구는 배열 전체를 다룰 때 잘 동작<br>
배열 일부에 대해 동작하는 반복문이 있다면 배열 일부를 새로운 배열로 나눌 수 있음

- 배열 전체를 다루기<br>
반복문을 대신해 어떤 함수형 도구를 사용해야 전체 배열을 한번에 처리할 수 있을지 고민하고 변경할 것<br>
map()은 모든 항목을 변환<br>
filter()는 항목을 없애거나 유지<br>
reduce()는 항목을 하나로 합침

- 작은 단계로 나누기<br>
한 번에 너무 많은 일을 처리하고 있다면 두 개 이상의 단계로 나누기<br>
작은 단계는 더 단순하므로 만들려는 목적에 얼마나 가까운지 생각하며 나누기

- 조건문을 filter()로 바꾸기<br>
반복문 안에 있는 조건문은 항목을 건너뛰기 위해 사용하는 경우가 있음 -> 이 때 filter() 사용!

- 유용한 함수로 추출하기<br>
map(), filter(), reduce() 외에도 다양한 함수가 있으니 고려해보기

- 개선을 위해 실험하기<br>
좋은 방법을 찾기 위해 함수형 도구를 새로운 방법으로 조합해보기


<br>

## 체이닝 디버깅
고차 함수에 문제가 생겼을 때 디버깅을 위한 팁
- 구체적인 것을 유지하기<br>
데이터를 처리하는 과정에서 데이터가 어떻게 생겼는지 잊어버리기 쉬움<br>
각 단계에서 어떤 것을 하고 있는지 알기 쉽게 의미있는 이름 짓기

- 출력해보기<br>
각 단계에서 print 구문으로 예상대로 동작하는지 확인하기
복잡한 체인의 경우 한 번에 한 단계씩 결과를 확인하고 다음 단계를 추가할 것

- 타입을 따라가보기<br>
javascript는 타입이 없지만 함수형 도구는 정확한 타입이 있음(컴파일 타임에 검사하지 않을 뿐)<br>
map()은 새로운 배열을 리턴, 콜백이 리턴하는 타입의 값이 들어있을 것<br>
reduct()의 결과값은 콜백이 리턴하는 값과 동일함, 초기값과도 동일<br>
각 단계에서 만들어지는 값의 타입을 따라가면 단계를 살펴볼 수 있음


<br>

## 다양한 함수형 도구 (P.341 참고)

### `pluck()`
map() 사용 시 특정 필드값을 가져오기 위해 콜백을 매번 작성해야 하지만 pluck()는 그렇지 않음
### `concat()`
배열 안에 배열을 뺄 수 있음, 중첩된 배열을 한 단계의 배열로 만듦
### `frequnciesBy()`와 `GroupBy()`
개수를 세거나 그룹화 하는일에 사용, 객체 또는 맵을 리턴함


<br>

## 데이터를 사용해 함수형 체이닝
- 인자를 데이터로 표현 -> 함수형 프로그래밍에서 자주 사용하는 방법<br>
ex)배열에 동작 이름과 제품 이름인 인자를 넣어 동작을 완전한 데이터로 표현
- 인자를 데이터로 만들면 함수형 도구를 체이닝하기 좋음
- 리턴할 데이터를 다음 단계의 인자처럼 쓸 수 있도록 만들어보기

<br>

#### 함수형 프로그래머는 `계산` === `데이터 변환`

<br>

<hr>

` 🔍 용어 정리 `
- `항등 함수(identity function)` : 인자로 받은 값을 그대로 리턴하는 함수

<hr>